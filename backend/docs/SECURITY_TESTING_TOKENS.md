# Token Security Testing Plan

## 1. Goals

- Verify JWT expiration is enforced correctly.
- Confirm behavior for long-running sessions.
- Define a plan for token refresh (even if not yet implemented).
- Verify logout and concurrent session behavior.

## 2. Current Behavior Overview

- JWTs are generated by `JwtUtil` with:
  - Secret: `jwt.secret` (see `application.yml`)
  - Expiration: `jwt.expiration` (currently 86,400,000 ms = 24 hours)
- Validation checks:
  - Subject (email) matches user
  - Token is not expired (`!isTokenExpired(token)`)
- Frontend stores token in `localStorage` and attaches it via `Authorization: Bearer <token>`.
- On 401 responses, frontend clears token and forces re-login.

## 3. Expiration Testing

### 3.1 Manual Expiration Test

1. Log in and capture a JWT (`token`).
2. Decode the token (e.g., using `jwt.io`) and note the `exp` claim.
3. Wait until after expiration (or temporarily set `jwt.expiration` to a short value, e.g., 60 seconds in a test profile).
4. Call a protected endpoint (e.g., `GET /api/auth/me`) with the expired token.

**Expected**:

- Backend returns `401 Unauthorized` or `403 Forbidden`.
- Frontend clears token and shows “Session expired. Please log in again.”.

### 3.2 Automated Expiration Test (Integration)

- Write an integration test that:
  - Generates a token with very short expiration.
  - Sleeps beyond expiration.
  - Asserts that validation fails and the endpoint returns 401.

## 4. Token Refresh (Planned)

### 4.1 Design Notes (Not Implemented Yet)

- Use short-lived access tokens + longer-lived refresh tokens.
- Store refresh tokens securely (e.g., HttpOnly cookies).
- Add endpoints:
  - `POST /api/auth/refresh` — exchange valid refresh token for new access token.
  - `POST /api/auth/logout` — revoke refresh token.

**Action Items**:

- [ ] Design refresh token schema and storage.
- [ ] Implement `/api/auth/refresh` endpoint.
- [ ] Implement `/api/auth/logout` with server-side revocation.
- [ ] Add integration tests for refresh and logout flows.

## 5. Long-Running Session Testing

- [ ] Simulate a user staying logged in for 24+ hours.
  - Use a test environment with `jwt.expiration` set appropriately.
  - Verify that:
    - Token eventually expires.
    - Frontend responds gracefully and prompts re-login.

## 6. Logout & Concurrent Sessions

### 6.1 Logout Behavior

- [ ] Verify that frontend logout clears token from `localStorage` and axios defaults.
- [ ] Ensure `AuthContext` and `AdminAuthContext` remove user state on logout.

### 6.2 Concurrent Sessions

- [ ] Log in from two different browsers/devices with the same account.
- [ ] Verify behavior when:
  - One session logs out (does not affect the other, since JWTs are stateless).
  - Token is rotated (after refresh implementation).

## 7. Results Tracking

| Test Case                          | Status | Notes |
| ---------------------------------- | ------ | ----- |
| Expired token rejected             |        |       |
| Short-lived token integration test |        |       |
| Refresh endpoint implemented       |        |       |
| Logout revokes refresh tokens      |        |       |
| Long-running session behavior      |        |       |
| Concurrent session behavior        |        |       |

## 8. Conclusion

Current implementation:

- Uses time-limited JWTs with server-side validation.
- Relies on frontend to clear tokens on 401.

Planned improvements:

- Add refresh token flow for better UX.
- Add server-side revocation (logout) and improved concurrent session handling.

This document provides the test plan; implementation work for refresh/revocation is tracked separately in the improvement plan.

{
"cells": [],
"metadata": {
"language_info": {
"name": "python"
}
},
"nbformat": 4,
"nbformat_minor": 2
}
